#高级运算符 

## 溢出运算符  
> swift的算数运算符出现溢出时会抛出运算时错误  
> swift有溢出运算符（&+、&-、&*），用来支持溢出运算  
		
		var min = Uint8.min 
		print(min &- 1) // 255, Int8.max  
		
		var max = UInt8.max  
		print(max &+ 1) // 0, Int8.min  
		print(max &* 2) // 254, 等价于 max &+ max
		
## 运算符重载  
		
		struct Point {
			var x: Int, y: Int
		}
		func + (p1: Point, p2: Point) -> Point {
			return Point(x: p1.x + p2.x, y: p1.y + p2.y)
		}

		print(Point(x: 10, y: 12) + Point(x: 11, y: 13)) // Point(x: 21, y: 25)  
		
		// 可以通过运算符的重载解决swift中没有，oc中有的运算符  
		struct Point {
			var x: Int, y: Int
			static func + (p1: Point, p2: Point) -> Point {
				return Point(x: p1.x + p2.x, y: p1.y + p2.y)
    		}
    		static func += (p1: Point, p2: Point) -> Point {
    			return p1 + p2
		    }
		    static prefix func ++ (p: inout Point) -> Point {
		    	return p += Point(x: 1, y: 1)
    		}
		}
		
## Equatable  
> 要想得知2个实例是否等价，一般做法是遵守Equatable ，重载 == 运算符  
> 于此同时，等价于重载了 ！= 运算符      
> swift 为以下类型提供默认的Equatable实现      
 - 没有关联类型的枚举  
 - 只拥有遵守Equatable协议关联类型的枚举  
 - 只拥有遵守Equatable协议存储属性的结构体  
> 引用类型比较存储的地址值是否相等（是否引用着同一对象），使用恒等运算符 ===、!==   
		
		struct Point: Equatable {
			var x: Int, y: Int
		}
		var p1 = Point(x: 10, y: 11)
		var p2 = Point(x: 12, y: 13)
		print(p1 == p2) // false
		print(p1 != p2) // true

## Comparable  
> 要想比较两个实例的大小，一般做法是    
 - 遵守Comparable协议  
 - 重载相应的运算符  
		
		struct Student: Comparable {
			var age: Int
			var score: Int
			init(score: Int, age: Int) {
				self.score = score
				self.age = age
			}
			static func < (lhs: Student, rhs: Student) -> Bool {
				(lhs.score < rhs.score) || (lhs.score == rhs.score && lhs.age > rhs.age)
   	 		}
    		static func > (lhs: Student, rhs: Student) -> Bool {
        		(lhs.score > rhs.score) || (lhs.score == rhs.score && lhs.age < rhs.age)
    		}
    		static func <= (lhs: Student, rhs: Student) -> Bool {
        		!(lhs > rhs)
    		}
    		static func >= (lhs: Student, rhs: Student) -> Bool {
        		!(lhs < rhs)
    		}
		}
## 自定义运算符   
> 可以自定义新的运算符： 在全局作用域使用operator进行申明  
		
		prefix operator // 前缀运算符
		postfix operator // 后缀运算符
		infix operator //中缀运算符
		precedencegroup 优先级组 {
			associativity: 结合性（left、right、none）
			higherThan: 比谁的优先级高
			lowerThan: 比谁的优先级低
			assignment: true 代表在可选链操作中拥有跟赋值运算符一样的优先级
		}  
	
		prefix operator +++
		infix operator +- : PlusMinusPrecedence
		precedencegroup PlusMinusPrecedence {
			associativity: none
			higherThan: AdditionPrecedence
			lowerThan: MultiplicationPrecedence
			assignment: true
		}

		struct Point {
			var x: Int, y: Int
			static prefix func +++ (point: inout Point) -> Point {
				 point = Point(x: point.x + point.x, y: point.y + point.y)
				 return point
   	 		}
    		static func +- (left: Point, right: Point) -> Point {
        		return Point(x: left.x + right.x, y: left.y - right.y)
    		}
    
    		static func +- (left: Point?, right: Point) -> Point {
        		return Point(x: left?.x ?? 0 + right.x, y: left?.y ?? 0 - right.y)
    		}
 
		}
		struct Person {
			var point: Point
		}
		var person = Person(point: Point(x: 1, y: 1))

		let point = person.point +- Point(x: 10, y: 20)

		print(point)

