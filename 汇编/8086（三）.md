# 8086（三）
## DS和【address】

* cpu 要读写一个内存单元时，必须要先给出这个内存单元的地址在8086中，内存地址由段地址和偏移地址组成
* 8086中有个ds段寄存器，通常用来存放要访问的数据的段地址。但是8086不支持将数据直接放入寄存器中，**mov ds ，1000H 是错误的**  

> mov bx ,1000H  
> mov ds ,bx  
> mov al ,[0]  

上面3条指令的作用是将1000H（1000：0）中的内存数据复制到al寄存器中。mov al，[address]的意思就是将DS：address中内存数据复制到al寄存器中。由于al是8位寄存器，所以是将一个字节的数据复制个al寄存器  

eg： 写几条指令，将al中的数据送入内存单元10000H中  
> mov bx, 1000H  
> mov ds,bx  
> mov [0],al  

## 大小端  
* 大端模式：是指高字节保存到内存低地址中，而数据的低字节保存到内存高地址中  
* 小端模式：是指高字节保存到内存的高地址中，而数据的低字节保存到内存的低地址中  

## mov指令  
* mov 寄存器，数据   比如：mov ax，8  
* mov 寄存器，寄存器  比如：mov ax，bx  
* mov 寄存器，内存单元 比如：mov ax，[0]
* mov 内存单元，寄存器 比如：mov [0],ax  
* mov 段地址，寄存器  比如：mov ds，ax
* mov 寄存器，段寄存器  
** mov 内存单元 ，内存单元** 是不允许的，比如mov [1],[0]

## add和sub指令  
add和sub指令和mov一样，都要两个操作对象  
* add 寄存器，数据   比如：add ax，8  
* add 寄存器，寄存器  比如：add ax，bx  
* add 寄存器，内存单元 比如：add ax，[0]
* add 内存单元，寄存器 比如：add [0],ax  
  
* sub 寄存器，数据   比如：sub ax，8  
* sub 寄存器，寄存器  比如：sub ax，bx  
* sub 寄存器，内存单元 比如：sub ax，[0]
* sub 内存单元，寄存器 比如：sub [0],ax   

## 栈  
* 栈：是一种具有特殊的访问方式的储存空间（先进后出）  
* 8086 会将cs作为代码段的段地址，将cs：ip指向的指令作为下一条指令  
* 8086 会将ds作为数据段的段地址，mov ax，【address】就是取出DS：address中的数据放到ax中  
* 8086 会将ss作为栈段的段地址，任意时刻，ss：IP指向栈顶元素  
* 8086 提供了PUSH和POP指令来操作栈段的数据  
  
**思考**  
> 如果10000H~1000FH 这段空间当作栈，初始转态栈是空的，此时，ss=1000H，sp = ？ **栈空，ss：sp指向栈空间最高地址单元的下一个单元**  

## 栈顶超界  
&emsp;&emsp;&emsp;&emsp;当栈满的时候再使用push指令入栈，或者栈空的时候在使用pop指令出栈，都将会产生栈顶超界的问题。假想：CPU 中有记录栈顶上限和栈低的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围。然后，CPU在执行push执行的时候靠检查栈顶上限、在执行pop指令的时候靠检查栈低寄存器保证不会越界。  
&emsp;&emsp;&emsp;&emsp;实际上8086没有这样的功能，他只知道栈顶（ss:SP），并不知道栈空间多大。所以这块要程序员自己解决  

## push 和pop 常用的指令格式  
* push 寄存器 ；  将一个寄存器中的数据入栈
* pop寄存器 ；  出栈，用一个寄存器接受出栈的数据
* push 段寄存器 ；  将一个段寄存器中的数据入栈  
* pop 段寄存器 ；  出栈，用一个段寄存器接受出栈的数据
* push 内存单元 ；  将一个内存单元中的字入栈（注意，栈操作都是以字为单位）
* pop 内存单元 ；出栈，用一个内存字单元接受出栈的数据  
  
 **eg:**  
 > mov ax,1000H  
 > mov ds,ax  ;内存单元的段地址要放在ds中 
 >push [0]  ;将1000：0处的字压入栈中
 >pop [2]	  ; 出栈。出栈的数据送入1000：2中  
 
 ####编程：  
 > 1. 将10000H~1000FH 这段空间当做栈，初始状态栈是空的 
 > 2. 设置AX = 001AH，BX = 001BH  
 > 3. 利用栈，交换ax和bx中的数据  
 
 ```
  mov ax,1000H  
  mov ss,ax  
  mov sp,0010H  
  mov ax, 001AH  
  mov bx, 001BH  
  push ax  
  push bx  
  
  pop ax 
  pop bx 
  
 ```  
 ## 伪指令  
 ```
 assume cs:code  
 code segment 
 		mov ax,1122h
 		mov bx,3344h  
 		add ax,bx  
 		
 		mov ah,4ch  
 		int 21h  
 code ends  
 end
   
 ```  
 * segment 和ends的作用是定义一个段，segment代表一个段的开始，ends代表一个段的结束 使用格式 ：  
 ```
 段名 segment  
 :   
 段名 ends   
 ```  
 * 一个有意义的汇编程序中，至少要有一个段作为代码段存放代码  
 * assume ：声明一下code段是cs段，代码段  
 * end： 编译器遇到end时，就结束对源程序的编译  
 
 ## 中断  
 * 中断是由于软件的或硬件的信号，使得个必须由CPU立即处理的情况，此时，CPU暂时中止当前程序的执行转而处理这个新情况的过程就叫做中断CPU暂停当前的任务，转而去执行另一段子程序  
 * 中断的分类  
 > 1. 硬中断（外中断）由外部设备(比如网卡、硬盘)随机引发的，比如当网卡收到数据包的时候，就会发出一个中断  
 > 2. 软中断（内中断），由执行中断指令产生的，可以通过程序控制触发
  
# DOS系统功能调用  
* DOS系统功能调用  
> 由DOS提供的一组实现特殊功能的子程序供程序员在编写自己的程序时调用，以减轻编程的工作量  
> 涉及屏幕显示、文件管理、I/O管理等  
> 每个子程序都有一个功能号，所有的功能调用的格式都是一致的 
```
；数据段
data segment  
	string db 'Hello world'
data ends  

mov ax ,data
mov ds ,ax ;设置ds为数据段

mov ah,9h ;功能号9h代表在屏幕显示字符串  
mov dx,offset string ;ds：代表字符串地址  
int 21h ; 执行DOS系统功能调用

```
